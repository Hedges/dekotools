#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "MmeDocument.h"

#include "MmeParser.hpp"
#define yyscan_t mme_scan_t
#define YYSTYPE MME_STYPE
#define YYLTYPE MME_LTYPE
#include "MmeLexer.hpp"

namespace
{
	enum SubmissionMode : uint32_t
	{
		Increasing       = 1,
		NonIncreasing    = 3,
		Inline           = 4,
		IncreaseOnce     = 5,
	};

	constexpr uint32_t ShiftField(uint32_t field, uint32_t pos, uint32_t size)
	{
		field &= (uint32_t{1} << size) - 1;
		return field << pos;
	}

	constexpr uint32_t MakeCmdHeader(SubmissionMode mode, uint16_t arg, uint8_t subchannel, uint16_t method)
	{
		return ShiftField(method, 0, 13) | ShiftField(subchannel, 13, 3) | ShiftField(arg, 16, 13) | ShiftField(mode, 29, 3);
	}
}

void mme_error(MME_LTYPE *llocp, mme_scan_t scanner, MmeDocument& doc, char const* curFile, char const *msg)
{
	//curFile = AbbreviatePath(doc.firstDir, curFile);
	fprintf(stderr, "%s:%d:%d: %s\n", curFile, llocp->first_line, llocp->first_column, msg);
	fprintf(stderr, "%s:%d:%d: (error ends here)\n", curFile, llocp->last_line, llocp->last_column);
}

static bool resolveLabels(std::vector<int32_t>& code, std::map<std::string, size_t>& labels, std::map<size_t, std::string>& refs)
{
	for (auto& ref : refs)
	{
		auto it = labels.find(ref.second);
		if (it == labels.end())
		{
			fprintf(stderr, "Undefined reference to %s\n", ref.second.c_str());
			return false;
		}
		if (ref.first < code.size())
		{
			int32_t& inst = code[ref.first];
			int32_t target = it->second - int32_t(ref.first);
			inst = (inst &~ mme::ImmediateMask) | mme::MakeImmediate(target);
		}
	}
	refs.clear();
	return true;
}

bool MmeDocument::ResolveLocalLabels()
{
	bool ok = resolveLabels(m_code, m_localLabels, m_localLabelRefs);
	m_localLabels.clear();
	return ok;
}

bool MmeDocument::ResolveLabels()
{
	return resolveLabels(m_code, m_labels, m_labelRefs);
}

bool MmeDocument::Load(const char* fileName)
{
	FILE* fin = fopen(fileName, "r");
	if (!fin)
	{
		fprintf(stderr, "%s: couldn't open file\n", fileName);
		return false;
	}

	mme_scan_t scanner;
	mme_lex_init(&scanner);
	mme_set_in(fin, scanner);
	int ret = mme_parse(scanner, *this, fileName);
	mme_lex_destroy(scanner);
	fclose(fin);

	if (ret==0)
		return ResolveLocalLabels() && ResolveLabels();

	return false;
}

void MmeDocument::GenerateHeader(FILE* f, const char* name, uint8_t subchannel)
{
	fprintf(f, "// Generated by dekomme\n");
	fprintf(f, "#pragma once\n");
	fprintf(f, "#include <stdint.h>\n\n");
	fprintf(f, "enum {\n");
	for (size_t i = 0; i < m_exports.size(); i ++)
		fprintf(f, "\t%s%s = 0x%x,\n", name, m_exports[i]->first.c_str(), 0xE00+2*(int)i);
	fprintf(f, "};\n\n");
	fprintf(f, "#ifdef __cplusplus\n");
	fprintf(f, "static constexpr uint32_t %s_SetupCmds[] = {\n", name);
	fprintf(f, "#else\n");
	fprintf(f, "static const uint32_t %s_SetupCmds[] = {\n", name);
	fprintf(f, "#endif\n");
	fprintf(f, "\t0x%08X,\n", // MmeInstructionRamPointer+MmeInstructionRamLoad
		MakeCmdHeader(SubmissionMode::IncreaseOnce, 1+m_code.size(), subchannel, 0x45));
	fprintf(f, "\t0x%08X,\n", 0);
	for (size_t i = 0; i < m_code.size(); i ++)
		fprintf(f, "\t0x%08X,\n", m_code[i]);
	fprintf(f, "\t0x%08X,\n", // MmeStartAddressRamPointer+MmeStartAddressRamLoad
		MakeCmdHeader(SubmissionMode::IncreaseOnce, 1+m_exports.size(), subchannel, 0x47));
	fprintf(f, "\t0x%08X,\n", 0);
	for (size_t i = 0; i < m_exports.size(); i ++)
		fprintf(f, "\t0x%08X,\n", int32_t(m_exports[i]->second));
	fprintf(f, "};\n");
}

bool MmeDocument::VisitEqu(std::string&& ident, int32_t value)
{
	auto ret = m_equs.emplace( std::move(ident), value );
	return ret.second;
}

bool MmeDocument::VisitLocalLabel(std::string&& ident)
{
	auto ret = m_localLabels.emplace( std::move(ident), m_code.size() );
	return ret.second;
}

bool MmeDocument::VisitLabel(std::string&& ident, bool exported)
{
	if (!ResolveLocalLabels())
		return false;
	auto ret = m_labels.emplace( std::move(ident), m_code.size() );
	if (ret.second && exported)
		m_exports.push_back(ret.first);
	return ret.second;
}

void MmeDocument::VisitInstruction(int32_t inst)
{
	m_code.push_back(inst);
}

void MmeDocument::VisitLabelRef(std::string&& ident, bool local)
{
	if (local)
		m_localLabelRefs.emplace( m_code.size(), std::move(ident) );
	else
		m_labelRefs.emplace( m_code.size(), std::move(ident) );
}

bool MmeDocument::VisitExprIdent(std::string&& ident, int32_t& value)
{
	auto it = m_equs.find(ident);
	if (it != m_equs.end())
	{
		value = it->second;
		return true;
	}
	return false;
}
